# -*- coding: utf-8 -*-
"""Rejection_rate_analysis_mask_4095 (3).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xgrLuvc6sdMwEW7Om5tqhhE3BzsAFgJ8
"""

q=3329
poly_size=256

import hashlib
import secrets
def shake_generate_input(seed, length):
    """
    Generate input bytes using SHAKE-128.

    Parameters:
    - seed (bytes): The seed input to SHAKE-128
    - length (int): The number of output bytes required (default: 384 bytes for Kyber512)

    Returns:
    - bytes: The generated pseudo-random byte string.
    """
    shake = hashlib.shake_128()
    shake.update(seed)
    return shake.digest(length)  # Generate 'length' bytes

def ntt_sample_iterate(byte_stream,poly_size):
        """
        Algorithm 1 (Parse)
        https://pq-crystals.org/kyber/data/kyber-specification-round3-20210804.pdf

        Algorithm 6 (Sample NTT)

        Parse: B^* -> R
        """
        q=3329
        i, j, k = 0, 0, 0
        coefficients = [0] * poly_size
        while j < poly_size:
            if i + 2 >= len(byte_stream):
              raise ValueError("Insufficient byte stream length")

            d1 = byte_stream[i] + 256 * (byte_stream[i + 1] % 16)
            d2 = (byte_stream[i + 1] // 16) + 16 * byte_stream[i + 2]


            if d1 < q:
                coefficients[j] = d1
                j = j + 1
            else:
                k=k+1

            if d2 < q and j < poly_size:
                coefficients[j] = d2
                j = j + 1
            else:
                k=k+1

            i = i + 3
        return coefficients, k, i


def ours(byte_stream, poly_size):  # OUR PROPOSED ALGORITHM
    """
    Generates a uniform set of polynomial coefficients suitable for NTT-based cryptography,
    ensuring no bias and avoiding rejection sampling.

    :param byte_stream: Source of uniform random bytes.
    :param q: Prime modulus for the finite field.
    :param poly_size: Number of polynomial coefficients (default: 256).
    :return: A list of polynomial coefficients mod q.
    """
    i = 0
    j = 0
    k=0
    poly_coeffs = [0]*poly_size  # Stores NTT polynomial coefficients

    q_bits = q.bit_length()  # Minimum bits required for q
    max_value = (1 << q_bits)  # Smallest power of 2 greater than q
    #print("The max_value",max_value)
    mask = max_value - 1  # Efficient bitmask for extracting bits
    #print("The mask is",mask)

    while j < poly_size:
        if i + 1 >= len(byte_stream):
            raise ValueError("Insufficient byte stream length")

        # Read 4 bytes at once for efficiency
        #b1, b2, b3, b4 = byte_stream[i:i+4]
        b1, b2= byte_stream[i:i+2]

        # Construct 16-bit numbers and map efficiently
        d1 = (b1 | (b2 << 8)) & mask
        d2 = (b2 | (b1 << 8)) & mask
        #print("Before mask d1: ",d1)
        #print("Before mask d2: ",d2)
        # Instead of rejection, map values using multiplication trick


        if d1 < 3329:
                poly_coeffs[j] = d1
                j = j + 1
        else:
            k=k+1


        if d2 < 3329 and j < poly_size:
                poly_coeffs[j] = d2
                j = j + 1
        else:
             k=k+1

        i += 2  # Move to next 4-byte block

    return poly_coeffs, k, i

def parse_spdm3_with_reject_count(byte_stream, poly_size):
    """
    Parse using SPDM3-style rejection sampling.
    """
    q = 3329
    i = 0
    j = 0
    a_hat = []

    total_candidates = 0
    accepted = 0
    rejected = 0

    while j < poly_size:
        d1 = 16 * byte_stream[i] + (byte_stream[i + 1] // 16)
        total_candidates += 1

        if d1 < 3584:
            i += 1

        d2 = (256 * byte_stream[i] % (2 ** 12)) + byte_stream[i + 1]
        total_candidates += 1

        if d1 < q:
            a_hat.append(d1)
            j += 1
            accepted += 1
        else:
            rejected += 1

        if d2 < q and j < poly_size:
            a_hat.append(d2)
            j += 1
            accepted += 1
        else:
            rejected += 1

        if d2 < 3584:
            i += 2
        else:
            i += 1
    return a_hat, i, rejected

seed_list=[]
for i in range(100000):
    seed_list.append(shake_generate_input(seed = secrets.token_bytes(32), length=600))
print(len(seed_list))
#print(len(seed_list[0]))

avg_rej_ours=[]
avg_total_candi_ours=[]
avg_bytes_ours=[]
for seed in seed_list:
    our_poly, total_rejection, required_bits=ours(seed, poly_size)
    avg_rej_ours.append(total_rejection)
    avg_bytes_ours.append(required_bits)
    avg_total_candi_ours.append(total_rejection+256)
av_re=sum(avg_rej_ours)/len(avg_rej_ours)
av_by=sum(avg_bytes_ours)/len(avg_bytes_ours)
av_rate=sum(avg_rej_ours)/sum(avg_total_candi_ours)
print(av_re)
print(av_by)
print(av_rate)

avg_rej_kyber=[]
avg_bytes_kyber=[]
avg_total_candi_kyber=[]
for seed in seed_list:
    li, total_rejection, required_bits=ntt_sample_iterate(seed, poly_size)
    avg_rej_kyber.append(total_rejection)
    avg_bytes_kyber.append(required_bits)
    avg_total_candi_kyber.append(total_rejection+256)
av_re=sum(avg_rej_kyber)/len(avg_rej_kyber)
av_by=sum(avg_bytes_kyber)/len(avg_bytes_kyber)
av_rate=sum(avg_rej_kyber)/sum(avg_total_candi_kyber)
print(av_re)
print(av_by)
print(av_rate)

avg_rej_korean=[]
avg_bytes_korean=[]
avg_total_candi_korean=[]
for seed in seed_list:
    li, i, rejected=parse_spdm3_with_reject_count(seed, poly_size)
    avg_rej_korean.append(rejected)
    avg_total_candi_korean.append(rejected+256)
    avg_bytes_korean.append(i)
av_re=sum(avg_rej_korean)/len(avg_rej_korean)
av_rate=sum(avg_rej_korean)/sum(avg_total_candi_korean)
av_by=sum(avg_bytes_korean)/len(avg_bytes_korean)
print(av_re)
print(av_rate)
print(av_by)

433.76362*8

